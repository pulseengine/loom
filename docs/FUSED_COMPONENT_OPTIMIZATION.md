# Fused Component Optimization

Specialized optimization for WebAssembly modules produced by component fusion (e.g., meld).

## Table of Contents

- [Overview](#overview)
- [The Meld-Loom Pipeline](#the-meld-loom-pipeline)
- [Fusion Artifacts and Optimization Targets](#fusion-artifacts-and-optimization-targets)
- [Optimization Passes](#optimization-passes)
  - [Pass 1: Adapter Devirtualization](#pass-1-adapter-devirtualization)
  - [Pass 2: Function Type Deduplication](#pass-2-function-type-deduplication)
  - [Pass 3: Dead Function Elimination](#pass-3-dead-function-elimination)
  - [Pass 4: Import Deduplication](#pass-4-import-deduplication)
- [Correctness Proofs](#correctness-proofs)
- [Integration with loom Pipeline](#integration-with-loom-pipeline)
- [Usage](#usage)
- [Architecture Decision Log](#architecture-decision-log)

---

## Overview

When multiple P2/P3 WebAssembly components are **fused** into a single core module, the result contains characteristic patterns that standard optimization passes miss. The fused component optimizer targets these patterns specifically, achieving additional size and performance improvements beyond what loom's standard 12-phase pipeline provides.

### What It Actually Does

Component fusion (performed by tools like meld) combines multiple components into one module. This process introduces:
- **Adapter trampolines** for cross-component calls
- **Duplicate function types** from each source component
- **Duplicate imports** where multiple components imported the same external function
- **Dead functions** (adapters that can be bypassed)

The fused optimizer detects and eliminates these artifacts.

---

## The Meld-Loom Pipeline

```
P2/P3 Components          meld fuse            loom optimize
 +-----+ +-----+    +------------------+    +--------------+
 |Comp | |Comp |    |  Parse - Resolve |    | Fused Optim  |
 |  A  | |  B  |--->|  - Merge - Adapt |--->|  + 12-Phase  |
 +-----+ +-----+    |  - Encode        |    |  Pipeline    |
                     +------------------+    +--------------+
                            |                       |
                            v                       v
                   Single Core Module      Optimized Module
                   (with adapters)         (production-ready)
```

**Meld** handles the structural transformation: resolving dependencies, merging index spaces, generating adapter trampolines, and producing a valid single-module output.

**loom** handles the semantic optimization: devirtualizing adapters, eliminating dead code, folding constants, reducing strength, and verifying correctness.

Together they enable **whole-program optimization across former component boundaries** - something neither tool can achieve alone.

---

## Fusion Artifacts and Optimization Targets

### Adapter Trampolines

When component A calls a function exported by component B, meld generates an **adapter trampoline**. For direct adapters (no memory crossing), this is a trivial forwarding function:

```wasm
;; Generated by meld: adapter from component 0 to component 1
(func $adapter_0_0_to_1_0 (param i32) (result i32)
  local.get 0        ;; Forward parameter
  call $target_func  ;; Call the actual target
  ;; Results pass through automatically
)
```

For memory-crossing adapters (multi-memory mode), the adapter is more complex:

```wasm
;; Generated by meld: memory-crossing adapter with cabi_realloc
(func $adapter_mem_crossing (param i32 i32) (result i32 i32)
  ;; 1. Allocate in callee memory via cabi_realloc
  ;; 2. Copy data from caller memory to callee memory
  ;; 3. Call target with callee-memory pointers
  ;; 4. Copy results back
  ;; 5. Return caller-memory pointers
)
```

### Duplicate Function Types

Each source component contributes its own type section. After fusion, the merged type section contains duplicates:

```
;; Before deduplication (3 components, each has (i32) -> i32):
Type 0: (func (param i32) (result i32))  ;; from component A
Type 1: (func (param i32 i32) (result))  ;; from component A
Type 2: (func (param i32) (result i32))  ;; from component B (duplicate of 0)
Type 3: (func (param i32) (result i32))  ;; from component C (duplicate of 0)

;; After deduplication:
Type 0: (func (param i32) (result i32))  ;; canonical
Type 1: (func (param i32 i32) (result))  ;; canonical
;; Type refs 2 and 3 remapped to 0
```

### Duplicate Imports

Multiple components may import the same external function:

```
;; Before deduplication:
Import 0: (import "wasi:io/streams" "read" (func (type 0)))  ;; from component A
Import 1: (import "wasi:io/streams" "read" (func (type 0)))  ;; from component B
Import 2: (import "wasi:io/streams" "write" (func (type 1))) ;; unique

;; After deduplication:
Import 0: (import "wasi:io/streams" "read" (func (type 0)))  ;; canonical
Import 1: (import "wasi:io/streams" "write" (func (type 1))) ;; unique
;; All references to old import 1 remapped to import 0
```

---

## Optimization Passes

### Pass 1: Adapter Devirtualization

**What**: Detect trivial adapter trampolines and rewrite callers to bypass them.

**Pattern detected**:
```wasm
(func $adapter (param p0 p1 ... pN) (result r0 r1 ... rM)
  local.get 0
  local.get 1
  ...
  local.get N
  call $target
)
```

**Transformation**: Replace `call $adapter` with `call $target` at every call site.

**Why this is correct**: The adapter pushes exactly the same arguments onto the stack in the same order and calls the target. It is semantically identical to calling the target directly. No locals are modified, no control flow exists, no side effects occur.

**Handles adapter chains**: If adapter A calls adapter B which calls target T, we resolve transitively: A -> T and B -> T.

### Pass 2: Function Type Deduplication

**What**: Merge structurally identical function types and remap all references.

**How**: Hash each type by its parameter and result lists. Build a canonical mapping. Update all type references (imports, `call_indirect`).

**Safety**: Skipped when raw type section bytes are present (GC/reference types) since those require complex re-encoding.

### Pass 3: Dead Function Elimination

**What**: Remove functions with no callers and no exports.

**How**: Build a liveness set from export roots and start function. Walk the call graph transitively. Remove unreachable functions and remap indices.

**Conservative**: If element segments exist (indirect call tables), all functions are conservatively marked as live since indirect call targets cannot be statically determined from raw bytes.

### Pass 4: Import Deduplication

**What**: Merge identical imports (same module + name + type).

**How**: Hash each import by module name, field name, and type index. Build canonical mapping. Remap all function references (imported function indices shift, local function indices shift by the reduction count).

---

## Correctness Proofs

Each transformation has a corresponding formal proof in Rocq:

| Transformation | Proof File | Theorem |
|---|---|---|
| Adapter devirtualization | `proofs/simplify/FusedOptimization.v` | `adapter_devirtualization_correct` |
| Type deduplication | `proofs/simplify/FusedOptimization.v` | `type_dedup_preserves_semantics` |
| Dead function elimination | `proofs/simplify/FusedOptimization.v` | `dead_function_elim_correct` |
| Import deduplication | `proofs/simplify/FusedOptimization.v` | `import_dedup_preserves_semantics` |

### Proof Strategy

**Adapter Devirtualization** uses a direct equivalence proof:

```
For adapter A with body: local.get 0; ...; local.get N; call T; end
For any state S and continuation K:

  step(K[call A], S)
= step(K[local.get 0; ...; call T; end], S)    -- inline body
= step(K[call T], S)                            -- local.gets reconstruct stack

Therefore: call A = call T
```

**Type Deduplication** uses structural equality:

```
For types T_i and T_j where params(T_i) = params(T_j) and results(T_i) = results(T_j):
  Any instruction referencing T_i behaves identically when referencing T_j.
```

**Dead Function Elimination**: Unreachable code cannot affect observable behavior.

**Import Deduplication**: Same module + name + type resolve to the same external binding.

---

## Integration with loom Pipeline

The fused optimizer runs **before** loom's standard 12-phase pipeline:

```
Input WASM Module (from meld)
    |
    v
+-------------------------------+
|  Fused Component Optimization |  <-- NEW
|  1. Adapter devirtualization  |
|  2. Type deduplication        |
|  3. Dead function elimination |
|  4. Import deduplication      |
+-------------------------------+
    |
    v
+-------------------------------+
|  loom 12-Phase Pipeline       |
|  1. Constant folding (ISLE)   |
|  2. Advanced instructions     |
|  3. Local simplification      |
|  4. Dead code elimination     |
|  5. Code folding              |
|  6. Loop invariant motion     |
|  7. Branch simplification     |
|  8. Added constant optim      |
|  9. (Z3 verification)         |
+-------------------------------+
    |
    v
Optimized WASM Module
```

**Why before?** Adapter devirtualization creates dead code (unused adapters) and simplifies call graphs, which benefits all subsequent passes. Type and import deduplication reduce index space sizes, improving analysis precision.

---

## Usage

### As Part of the Meld-Loom Pipeline

```bash
# Step 1: Fuse components with meld
meld fuse component_a.wasm component_b.wasm -o fused.wasm

# Step 2: Optimize fused module with loom
loom optimize fused.wasm -o optimized.wasm
```

loom automatically detects fusion artifacts and applies the fused optimizer.

### Programmatic API

```rust
use loom_core::fused_optimizer::{optimize_fused_module, FusedOptimizationStats};
use loom_core::Module;

let mut module: Module = parse_wasm(&bytes)?;

// Apply fused-specific optimizations first
let stats: FusedOptimizationStats = optimize_fused_module(&mut module)?;
println!("Adapters devirtualized: {}", stats.calls_devirtualized);
println!("Types deduplicated: {}", stats.types_deduplicated);
println!("Dead functions eliminated: {}", stats.dead_functions_eliminated);
println!("Imports deduplicated: {}", stats.imports_deduplicated);

// Then apply standard loom optimizations
optimize_module(&mut module)?;
```

---

## Architecture Decision Log

### Why Devirtualize at the Module Level?

**Decision**: Detect and eliminate adapter patterns in loom rather than in meld.

**Rationale**: Meld must generate adapters for correctness (they handle Canonical ABI boundary crossing). Only after fusion is complete can we determine which adapters are trivial and can be bypassed. loom, as the optimizer, is the natural place for this analysis.

### Why Conservative Dead Function Elimination?

**Decision**: Mark all functions as live when element segments exist.

**Rationale**: Element segments populate indirect call tables (`call_indirect`). Without parsing the element section to extract exact function references, we cannot know which functions might be called indirectly. Per loom's philosophy: "a correct optimizer that handles 50% of cases is infinitely better than a fast optimizer that corrupts 1% of cases."

### Why Import Deduplication Before the Standard Pipeline?

**Decision**: Run import deduplication early to normalize the index space.

**Rationale**: Every import affects all function indices (local functions are numbered after imports). Removing duplicate imports shifts indices, which is cleaner to do once before the standard pipeline runs multiple analysis passes.

### Why Only Function Import Deduplication?

**Decision**: Only deduplicate function imports, not memory/table/global imports.

**Rationale**: Memory, table, and global imports have richer semantics (mutability, limits, element types). Deduplicating them requires deeper analysis to verify they are truly identical. Function imports are the most common duplicates after fusion and are safe to merge when module+name+type match.
