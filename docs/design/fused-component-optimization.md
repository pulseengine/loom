# Fused Component Optimization

Specialized optimization for WebAssembly modules produced by component fusion (e.g., meld).

## Overview

When multiple P2/P3 WebAssembly components are **fused** into a single core module, the result contains characteristic patterns that standard optimization passes miss. The fused component optimizer targets these patterns specifically, achieving additional size and performance improvements beyond what loom's standard 12-phase pipeline provides.

Component fusion (performed by tools like meld) combines multiple components into one module. This process introduces:
- **Adapter trampolines** for cross-component calls
- **Duplicate function types** from each source component
- **Duplicate imports** where multiple components imported the same external function
- **Dead functions** (adapters that can be bypassed)

The fused optimizer detects and eliminates these artifacts.

---

## The meld-loom Pipeline

```mermaid
flowchart LR
    subgraph Input
        A[Component A.wasm]
        B[Component B.wasm]
    end

    subgraph meld["meld fuse"]
        Parse --> Resolve --> Merge --> Adapt --> Encode
    end

    subgraph loom["loom optimize"]
        Fused["Fused Optimizer"] --> Pipeline["12-Phase Pipeline"]
    end

    A --> Parse
    B --> Parse
    Encode --> Fused
    Pipeline --> Out[Optimized Module]
```

**meld** handles the structural transformation: resolving dependencies, merging index spaces, generating adapter trampolines, and producing a valid single-module output.

**loom** handles the semantic optimization: devirtualizing adapters, eliminating dead code, folding constants, reducing strength, and verifying correctness.

Together they enable **whole-program optimization across former component boundaries** - something neither tool can achieve alone.

---

## Fusion Artifacts

### Adapter Trampolines

When component A calls a function exported by component B, meld generates an **adapter trampoline**:

```mermaid
flowchart LR
    subgraph before["Before (fused, unoptimized)"]
        Caller -->|call| Adapter
        Adapter -->|"local.get 0..N; call"| Target
    end

    subgraph after["After (devirtualized)"]
        Caller2[Caller] -->|"call (direct)"| Target2[Target]
    end

    before --> after
```

For **direct adapters** (shared memory), the adapter is a trivial forwarding function:

```wasm
;; Generated by meld: adapter from component 0 to component 1
(func $adapter (param i32) (result i32)
  local.get 0        ;; Forward parameter
  call $target_func  ;; Call the actual target
)
```

For **memory-crossing adapters** (multi-memory mode), the adapter is more complex:

```mermaid
flowchart TD
    Caller -->|"ptr, len"| Adapter
    Adapter -->|cabi_realloc| CalleeMemory[Callee Memory]
    Adapter -->|memory.copy| CalleeMemory
    Adapter -->|"new_ptr, len"| Target
    Target -->|results| Adapter
    Adapter -->|memory.copy back| CallerMemory[Caller Memory]
    Adapter -->|results| Caller
```

### Duplicate Function Types

Each source component contributes its own type section. After fusion, the merged type section contains duplicates:

```mermaid
flowchart LR
    subgraph before["Before Dedup"]
        T0["Type 0: (i32) → i32 ← Comp A"]
        T1["Type 1: (i32, i32) → () ← Comp A"]
        T2["Type 2: (i32) → i32 ← Comp B"]
        T3["Type 3: (i32) → i32 ← Comp C"]
    end

    subgraph after["After Dedup"]
        C0["Type 0: (i32) → i32 (canonical)"]
        C1["Type 1: (i32, i32) → ()"]
    end

    T0 --> C0
    T2 -->|"remapped"| C0
    T3 -->|"remapped"| C0
    T1 --> C1
```

### Duplicate Imports

Multiple components may import the same external function. These are merged and all references remapped.

---

## Optimization Passes

```mermaid
flowchart TD
    Input[Fused Module from meld] --> P1
    P1["Pass 1: Adapter Devirtualization"] --> P2
    P2["Pass 2: Function Type Deduplication"] --> P3
    P3["Pass 3: Dead Function Elimination"] --> P4
    P4["Pass 4: Import Deduplication"] --> Output
    Output[Cleaned Module] --> Standard["loom 12-Phase Pipeline"]
```

### Pass 1: Adapter Devirtualization

**What**: Detect trivial adapter trampolines and rewrite callers to bypass them.

**Pattern detected**:
```wasm
(func $adapter (param p0 p1 ... pN) (result r0 r1 ... rM)
  local.get 0
  local.get 1
  ...
  local.get N
  call $target
)
```

**Transformation**: Replace `call $adapter` with `call $target` at every call site.

**Why this is correct**: The adapter pushes exactly the same arguments onto the stack in the same order and calls the target. It is semantically identical to calling the target directly. No locals are modified, no control flow exists, no side effects occur.

**Handles adapter chains**: If adapter A calls adapter B which calls target T, we resolve transitively: A → T and B → T.

### Pass 2: Function Type Deduplication

**What**: Merge structurally identical function types and remap all references.

**How**: Hash each type by its parameter and result lists. Build a canonical mapping. Update all type references (imports, `call_indirect`).

**Safety**: Skipped when raw type section bytes are present (GC/reference types) since those require complex re-encoding.

### Pass 3: Dead Function Elimination

**What**: Remove functions unreachable from any export root.

**How**: Build a liveness set from export roots and start function. Walk the call graph transitively. Remove unreachable functions and remap indices.

**Conservative**: If element segments exist (indirect call tables), all functions are conservatively marked as live since indirect call targets cannot be statically determined from raw bytes.

### Pass 4: Import Deduplication

**What**: Merge identical imports (same module + name + type).

**How**: Hash each import by module name, field name, and type index. Build canonical mapping. Remap all function references (imported function indices shift, local function indices shift by the reduction count).

---

## Correctness Proofs

Each transformation has a corresponding formal proof in Rocq (`proofs/simplify/FusedOptimization.v`):

| Theorem | Status | Pass |
|---|---|---|
| `adapter_devirtualization_correct` | Admitted | Pass 1 |
| `devirtualization_preserves_module_semantics` | **Proven** | Pass 1 |
| `type_dedup_preserves_semantics` | **Proven** | Pass 2 |
| `type_dedup_idempotent` | Admitted | Pass 2 |
| `dead_function_elim_correct` | **Proven** | Pass 3 |
| `dead_function_removal_preserves_semantics` | **Proven** | Pass 3 |
| `import_dedup_preserves_semantics` | Admitted | Pass 4 |
| `fused_optimization_correct` | **Proven** | Combined |
| `fused_then_standard_correct` | Admitted | Composition |

### Proof Strategy

```mermaid
flowchart TD
    subgraph proven["Proven (Qed)"]
        DP["devirtualization_preserves_module"]
        TP["type_dedup_preserves_semantics"]
        DE["dead_function_elim_correct"]
        DR["dead_function_removal_preserves"]
        FC["fused_optimization_correct"]
    end

    subgraph admitted["Admitted (TODO)"]
        AD["adapter_devirtualization_correct"]
        TI["type_dedup_idempotent"]
        IP["import_dedup_preserves_semantics"]
        FS["fused_then_standard_correct"]
    end

    AD -->|"needed by"| FC
    TP --> FC
    DE --> FC
    IP -->|"needed by"| FC
    FC -->|"needed by"| FS
```

**Adapter Devirtualization** uses a direct equivalence proof:
- The adapter body `local.get 0; ...; local.get N; call T; end` reconstructs the parameter stack and delegates to the target
- Operationally equivalent to calling the target directly

**Type Deduplication** uses structural equality:
- If `params(T_i) = params(T_j)` and `results(T_i) = results(T_j)`, any instruction referencing `T_i` behaves identically when referencing `T_j`

**Dead Function Elimination**: Unreachable code cannot affect observable behavior.

**Import Deduplication**: Same module + name + type resolve to the same external binding per the WebAssembly specification.

---

## Integration with loom Pipeline

```mermaid
flowchart TD
    Input["Input WASM Module (from meld)"]
    Input --> Fused

    subgraph Fused["Fused Component Optimization"]
        F1["1. Adapter devirtualization"]
        F2["2. Type deduplication"]
        F3["3. Dead function elimination"]
        F4["4. Import deduplication"]
        F1 --> F2 --> F3 --> F4
    end

    Fused --> Standard

    subgraph Standard["loom 12-Phase Pipeline"]
        S1["1. Constant folding (ISLE)"]
        S2["2. Advanced instructions"]
        S3["3. Local simplification"]
        S4["4. Dead code elimination"]
        S5["5. Code folding"]
        S6["6. Loop invariant motion"]
        S7["7. Branch simplification"]
        S8["8. Added constant optim"]
        S9["9. Z3 verification"]
        S1 --> S2 --> S3 --> S4 --> S5 --> S6 --> S7 --> S8 --> S9
    end

    Standard --> Output["Optimized WASM Module"]
```

**Why before?** Adapter devirtualization creates dead code (unused adapters) and simplifies call graphs, which benefits all subsequent passes. Type and import deduplication reduce index space sizes, improving analysis precision.

---

## Usage

### As Part of the meld-loom Pipeline

```bash
# Step 1: Fuse components with meld
meld fuse component_a.wasm component_b.wasm -o fused.wasm

# Step 2: Optimize fused module with loom
loom optimize fused.wasm -o optimized.wasm
```

loom automatically detects fusion artifacts and applies the fused optimizer.

### Programmatic API

```rust
use loom_core::fused_optimizer::{optimize_fused_module, FusedOptimizationStats};
use loom_core::Module;

let mut module: Module = parse_wasm(&bytes)?;

// Apply fused-specific optimizations first
let stats: FusedOptimizationStats = optimize_fused_module(&mut module)?;
println!("Adapters devirtualized: {}", stats.calls_devirtualized);
println!("Types deduplicated: {}", stats.types_deduplicated);
println!("Dead functions eliminated: {}", stats.dead_functions_eliminated);
println!("Imports deduplicated: {}", stats.imports_deduplicated);

// Then apply standard loom optimizations
optimize_module(&mut module)?;
```

---

## Roadmap

### Implemented

| Feature | Status | Coverage |
|---|---|---|
| Trivial adapter devirtualization | Done | All direct adapters |
| Function type deduplication | Done | Basic types (skips GC) |
| Dead function elimination | Done | Conservative (skips tables) |
| Function import deduplication | Done | Function imports only |

### Planned

```mermaid
flowchart TD
    subgraph tier1["Tier 1: Proof Completion"]
        P1["Complete adapter_devirtualization proof"]
        P2["Complete type_dedup_idempotent proof"]
        P3["Complete import_dedup proof"]
        P4["Complete composition proof"]
    end

    subgraph tier2["Tier 2: More Optimizations"]
        T1["Post-return call elimination"]
        T2["Element segment parsing for better DCE"]
        T3["Memory-crossing adapter simplification"]
    end

    subgraph tier3["Tier 3: Advanced"]
        A1["String transcoding detection"]
        A2["Same-memory adapter collapse"]
    end

    tier1 --> tier2 --> tier3
```

| Feature | Priority | Impact | Effort |
|---|---|---|---|
| Complete admitted proofs | High | Correctness claims | Medium |
| Post-return call elimination | High | 10-30% adapter overhead reduction | Medium |
| Element segment parsing | Medium | Enables DCE with indirect calls | Medium |
| Memory-crossing adapter simplification | High | Eliminates entire adapters in shared-memory | High |
| String transcoding detection | Low | Rare but high savings when hit | Very High |

---

## Architecture Decision Log

### Why Devirtualize at the Module Level?

**Decision**: Detect and eliminate adapter patterns in loom rather than in meld.

**Rationale**: Meld must generate adapters for correctness (they handle Canonical ABI boundary crossing). Only after fusion is complete can we determine which adapters are trivial and can be bypassed. loom, as the optimizer, is the natural place for this analysis.

### Why Conservative Dead Function Elimination?

**Decision**: Mark all functions as live when element segments exist.

**Rationale**: Element segments populate indirect call tables (`call_indirect`). Without parsing the element section to extract exact function references, we cannot know which functions might be called indirectly. Per loom's philosophy: "a correct optimizer that handles 50% of cases is infinitely better than a fast optimizer that corrupts 1% of cases."

### Why Import Deduplication Before the Standard Pipeline?

**Decision**: Run import deduplication early to normalize the index space.

**Rationale**: Every import affects all function indices (local functions are numbered after imports). Removing duplicate imports shifts indices, which is cleaner to do once before the standard pipeline runs multiple analysis passes.

### Why Only Function Import Deduplication?

**Decision**: Only deduplicate function imports, not memory/table/global imports.

**Rationale**: Memory, table, and global imports have richer semantics (mutability, limits, element types). Deduplicating them requires deeper analysis to verify they are truly identical. Function imports are the most common duplicates after fusion and are safe to merge when module+name+type match.
