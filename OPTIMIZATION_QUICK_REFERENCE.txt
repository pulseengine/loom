=============================================================================
LOOM OPTIMIZATION PASSES - QUICK REFERENCE SUMMARY
=============================================================================

FILE LOCATIONS:
  Main optimizations: /home/user/loom/loom-core/src/lib.rs (lines 2954-5741)
  Component optimizer: /home/user/loom/loom-core/src/component_optimizer.rs
  ISLE rules: /home/user/loom/loom-shared/isle/wasm_terms.isle
  CLI pipeline: /home/user/loom/loom-cli/src/main.rs (lines 237-246)
  Tests: /home/user/loom/loom-core/tests/optimization_tests.rs

=============================================================================
OPTIMIZATION PIPELINE (Execution Order)
=============================================================================

PASS 1: precompute (Phase 19)                          Lines 4070-4120
  - Global constant propagation
  - Pattern: global.get(immutable) → constant value
  
PASS 2: constant_folding (Phase 12)                    Lines 2974-3007
  - ISLE-based term rewriting
  - Pattern: (i32.const X) (i32.const Y) i32.add → i32.const (X+Y)
  
PASS 3: eliminate_common_subexpressions (Phase 20)     Lines 4115-4633
  - MVP: Constants only (full expression CSE deferred)
  - Complex stack-based expression handling needs work
  
PASS 4: optimize_advanced_instructions (Issue #21)     Lines 4645-5178
  - Strength reduction: x * 8 → x << 3
  - Algebraic: x * 0 → 0, x ^ x → 0
  - Bitwise tricks (self-operations)
  
PASS 5: simplify_branches (Phase 15)                   Lines 3127-3240
  - Pattern: (i32.const 0) br_if → remove (never taken)
  - Pattern: (i32.const N) if → take then branch
  
PASS 6: eliminate_dead_code (Phase 14)                 Lines 3008-3125
  - Removes code after return/br/unreachable
  
PASS 7: merge_blocks (Phase 16)                        Lines 3241-3407
  - Merges compatible nested blocks (safety: no br inside)
  
PASS 8: vacuum (Phase 17)                              Lines 3408-3548
  - Cleanup: remove nops, unwrap trivial blocks
  - Safety: never unwrap loops (br_if targets)
  
PASS 9: simplify_locals (Phase 18)                     Lines 3549-3764
  - Equivalence canonicalization
  - Dead store detection (conservative)
  
ADDITIONAL OPTIMIZATIONS (Not in main pipeline):
  - coalesce_locals (Phase 12.5)                       Lines 3765-3996
    Register allocation via graph coloring
    
  - inline_functions (Issue #14)                       Lines 5179-5400
    Small function/single-site inlining
    
  - fold_code (Issue #22)                              Lines 5401-5480
    Temporary elimination & block flattening
    
  - optimize_loops (Issue #23)                         Lines 5481-5741
    Loop-invariant code motion (conservative)

=============================================================================
STRENGTH REDUCTION EXAMPLES
=============================================================================

Multiplication by power of 2:
  x * 8   →  x << 3
  x * 16  →  x << 4
  
Division by power of 2 (unsigned):
  x / 16  →  x >> 4
  x / 32  →  x >> 5
  
Remainder by power of 2 (unsigned):
  x % 32  →  x & 31
  x % 64  →  x & 63

=============================================================================
BITWISE ALGEBRAIC RULES
=============================================================================

Self-operations (3-instruction patterns):
  local.get $a; local.get $a; i32.xor  →  i32.const 0
  local.get $a; local.get $a; i32.and  →  local.get $a
  local.get $a; local.get $a; i32.or   →  local.get $a
  local.get $a; local.get $a; i32.sub  →  i32.const 0

Identity operations (2-instruction patterns):
  x + 0       →  x
  x - 0       →  x
  x * 1       →  x
  x / 1       →  x
  x ^ 0       →  x
  x << 0      →  x
  x >> 0      →  x
  x | 0       →  x
  x & 0xFFFF  →  x

Absorption operations:
  x & 0       →  0
  x | 0xFFFF  →  0xFFFF
  x % 1       →  0

=============================================================================
ISLE OPTIMIZATION INFRASTRUCTURE
=============================================================================

File: /home/user/loom/loom-shared/isle/wasm_terms.isle

ISLE Types Defined:
  - Imm32, Imm64 (immediate values)
  - Value (boxed recursive expressions)
  - ValueData enum (all WASM operations)
  - BlockType enum (control flow types)

Helper Functions (Immediate Arithmetic):
  - imm32_add, imm32_sub, imm32_mul, imm32_and, imm32_or, imm32_xor
  - imm32_shl, imm32_shr_s, imm32_shr_u (shift operations)
  - imm64_* (64-bit equivalents)

Main Rule:
  (decl simplify (Value) Value)
  (rule (simplify val) val)  ;; default: return unchanged

STATUS: Infrastructure in place, ISLE rules not yet implemented
REASON: Pending proper extractor setup for Value/ValueData pattern matching

=============================================================================
COMPONENT MODEL OPTIMIZATION
=============================================================================

File: /home/user/loom/loom-core/src/component_optimizer.rs

Phase 1: Core Module Optimization (lines 93-207)
  - Extracts all core modules
  - Applies full 12-phase pipeline to each
  - Reconstructs with optimized modules
  - 80-95% module code reduction expected

Phase 1.5: Full Section Preservation (lines 228-382)
  - Sections preserved: Types, Imports/Exports, Instances, etc.
  - Only CoreModule sections replaced with optimized versions

Phase 2: Component-Level Optimizations (Deferred)
  - Type deduplication (planned)
  - Unused import/export elimination (planned)
  - Canonical function optimization (planned)

=============================================================================
TODOs & LIMITATIONS
=============================================================================

Line 870:  Floating-point constants (F32, F64) not yet implemented

Line 2300: Function signature tracking needed for better call analysis

Line 3640: Dead store elimination incomplete (needs stack analysis)

Line 5481: Phase 4 of code folding incomplete (expression substitution)

Lines 4117-4135: CSE restricted to MVP due to stack safety concerns
  - Full expression-tree CSE deferred
  - Previous implementation had stack value leaks with local.tee

CSE Enhanced Version (lines 4283-4633):
  - Framework defined for expression trees
  - Phase 1-3 complete (build, find dupes, allocate locals)
  - Phase 4 transformation incomplete

Loop Optimizations:
  - LICM implemented but very conservative
  - Loop unrolling not implemented
  - Most operations marked non-invariant

Function Inlining:
  - MVP only: no parameter substitution
  - Needs stack value tracking for full implementation

=============================================================================
OPTIMIZATION BENEFITS EXPECTED
=============================================================================

Individual Pass Estimates:
  - Constant folding: 5-10%
  - Dead code elimination: 3-8%
  - Strength reduction & algebraic: 2-5%
  - Local coalescing (graph coloring): 10-15%
  - Function inlining: 5-10%
  - Branch simplification: 2-4%
  
COMBINED TOTAL: 25-50%+ binary size reduction possible

Real-world results typically 35-45% depending on input code patterns.

=============================================================================
SAFETY CONSTRAINTS
=============================================================================

CRITICAL: Block merging never merges blocks containing:
  - Br (unconditional branch)
  - BrIf (conditional branch)
  - BrTable (multi-way branch)
  Reason: Merging invalidates branch depth targets

CRITICAL: Loops never unwrapped in vacuum pass:
  - Loops contain br_if targeting outer block
  - Unwrapping removes the target label

Conservative: SimplifyLocals keeps dead stores for stack balance
  - Full elimination needs proper stack analysis

=============================================================================
