================================================================================
LOOM OPTIMIZATION PASSES - DETAILED TABLE
================================================================================

PIPELINE ORDER | PASS NAME              | FILE LOCATION         | KEY PATTERNS
================================================================================

1              | precompute             | lib.rs 4070-4120      | global.get → const
2              | constant_folding       | lib.rs 2974-3007      | (const X) (const Y) op
3              | eliminate_cse          | lib.rs 4115-4633      | duplicate expressions
4              | optimize_advanced      | lib.rs 4645-5178      | strength reduction
5              | simplify_branches      | lib.rs 3127-3240      | (const) br_if/if
6              | eliminate_dead_code    | lib.rs 3008-3125      | code after return
7              | merge_blocks           | lib.rs 3241-3407      | nested blocks
8              | vacuum                 | lib.rs 3408-3548      | nops, trivial blocks
9              | simplify_locals        | lib.rs 3549-3764      | equiv canonicalization

OPTIONAL       | coalesce_locals        | lib.rs 3765-3996      | graph coloring
OPTIONAL       | inline_functions       | lib.rs 5179-5400      | small functions
OPTIONAL       | fold_code              | lib.rs 5401-5480      | block flattening
OPTIONAL       | optimize_loops         | lib.rs 5481-5741      | loop invariants

================================================================================
OPTIMIZATION TRANSFORMATION EXAMPLES
================================================================================

PASS 4: Strength Reduction (optimize_advanced_instructions)
  Pattern                     Example Input           Example Output
  x * power_of_2              x * 8                   x << 3
  x / power_of_2              x / 16                  x >> 4
  x % power_of_2              x % 32                  x & 31
  
PASS 4: Algebraic Simplifications
  Pattern                     Example Input           Example Output
  x * 0                       (x) (const 0) i32.mul   i32.const 0
  x * 1                       (x) (const 1) i32.mul   (x) [remove ops]
  x + 0                       (x) (const 0) i32.add   (x) [remove ops]
  x - 0                       (x) (const 0) i32.sub   (x) [remove ops]
  x ^ 0                       (x) (const 0) i32.xor   (x) [remove ops]
  x % 1                       (x) (const 1) i32.rem   i32.const 0
  
PASS 4: Self-Operations (3-instruction patterns)
  Pattern                     Example                 Output
  x ^ x                       lg $a; lg $a; i32.xor   i32.const 0
  x & x                       lg $a; lg $a; i32.and   lg $a
  x | x                       lg $a; lg $a; i32.or    lg $a
  x - x                       lg $a; lg $a; i32.sub   i32.const 0

PASS 5: Branch Simplification
  Pattern                     Example                 Output
  (const 0) br_if             (c0) br_if $L           [removed - never taken]
  (const N) br_if             (c1) br_if $L           br $L [always taken]
  (const 0) if/else           (c0) if ... else E      [take else branch]
  (const N) if/else           (c1) if T ... else      [take then branch]

PASS 6: Dead Code Elimination
  Pattern                     Example                 Output
  code after return           return; i32.add         return; [remove add]
  code after br               br $exit; i32.const 1   br $exit; [remove const]
  code after unreachable      unreachable; (code)     unreachable; [remove code]

PASS 7: Block Merging (Safety: No branches inside!)
  Pattern                     Example                 Output
  block { block { X } }       block{ block{X} }       block { X }
  
PASS 8: Vacuum Cleanup
  Pattern                     Example                 Output
  nop instruction             nop                     [removed]
  trivial block (empty)       block {} end            [unwrapped]
  trivial block (single)      block { const 1 }       const 1 [unwrapped]

PASS 9: SimplifyLocals
  Pattern                     Example                 Output
  get src; set dst            lg $0; ls $1            (establish equiv)
  subsequent gets of dst      lg $1; (use)            lg $0; (use)
  
PASS 2: Constant Folding (ISLE)
  Pattern                     Example                 Output
  (const X) (const Y) add     (c100) (c200) i32.add   i32.const 300
  (const X) (const Y) mul     (c16) (c3) i32.mul      i32.const 48
  (const X) (const Y) and     (c0xFF) (c0x0F) i32.and i32.const 15

================================================================================
CRITICAL SAFETY CONSTRAINTS
================================================================================

1. BLOCK MERGING NEVER MERGES:
   Blocks containing: Br, BrIf, BrTable
   Reason: Merging invalidates branch depth targets
   
   UNSAFE MERGE EXAMPLE:
     block $outer {              block $outer {
       block $inner {      →?        (code)
         (code) br $outer            br $outer
       } (invalid!)
     }

2. VACUUM NEVER UNWRAPS LOOPS:
   Reason: Loops contain br_if targeting outer block
   Unwrapping removes the target label and invalidates branch
   
   UNSAFE UNWRAP EXAMPLE:
     loop $l {              (invalid!)
       (code) br_if $l      (code) br_if $l  ← label gone!
     }

3. SIMPLIFYLOCALS CONSERVATIVE:
   Dead stores kept for stack balance
   Reason: Full elimination needs proper stack value analysis
   
================================================================================
OPTIMIZATION IMPACT ESTIMATES
================================================================================

Pass                              Individual Reduction    Cumulative
─────────────────────────────────────────────────────────────────────
Constant folding                  5-10%                   5-10%
Eliminate CSE (MVP)               0-2%                    5-12%
Optimize advanced instructions    2-5%                    7-17%
Simplify branches                 2-4%                    9-21%
Eliminate dead code               3-8%                    12-29%
Merge blocks                       1-3%                    13-32%
Vacuum                            0-1%                    13-33%
Simplify locals                   1-2%                    14-35%
─────────────────────────────────────────────────────────────────────
Optional: Coalesce locals         10-15%                  24-50%
Optional: Inline functions        5-10%                   29-60%
─────────────────────────────────────────────────────────────────────

TOTAL EXPECTED (main pipeline):    25-35% reduction
WITH OPTIONAL PASSES:              35-50%+ reduction

Real-world results typically 35-45% depending on input patterns.

================================================================================
FILE STRUCTURE
================================================================================

Main Implementation:
  /home/user/loom/loom-core/src/lib.rs
    - pub mod optimize { ... } at line 2954
    - All optimization functions (2954-5741)
    
ISLE Infrastructure:
  /home/user/loom/loom-shared/isle/wasm_terms.isle
    - Value/ValueData types (lines 40-155)
    - Constructors (lines 164-410)
    - Helper functions (lines 423-505)
    - Optimization rules (lines 508-583)
    
Component Optimizer:
  /home/user/loom/loom-core/src/component_optimizer.rs
    - Phase 1: Core module optimization
    - Phase 1.5: Full section preservation
    - Phase 2: Component-level opts (deferred)
    
CLI Pipeline:
  /home/user/loom/loom-cli/src/main.rs
    - Lines 237-246: Optimization pipeline execution
    
Tests:
  /home/user/loom/loom-core/tests/optimization_tests.rs
    - Strength reduction tests (lines 29-105)
    - Algebraic simplification tests
    - Dead code elimination tests

================================================================================
